## Redis与数据库数据一致性问题

​	为了提高查询效率引入了redis作为缓存，但是出现了新的问题就是，缓存中的数据和数据库中的数据不一致问题。

​	解决数据不一致问题的方法，最简单的就是对缓存数据设置较短的过期时间，在过期时间后，会从数据库查询新的数据更新缓存，但是这种被动的等待过期时间，一致性是不符合大部分应用场景的。

  业内的解决方案

* Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案。
* Read/Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理。
* Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致。

​	**通常使用第一种方案，在更新数据库的同时更新缓存（删除缓存）。**

​	如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新缓存动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来。

我们需要考虑一下几点

1. 在数据库更新时，缓存是更新还是删除？

   1. 更新缓存：每次更新数据库都更新缓存，无效写操作较多。
   2. 删除缓存：更新数据库时让缓存失效，查询时再更新缓存。**√**

2. 怎么确保数据库更新，缓存也更新（删除），

   1. 单体系统，将缓存与数据库操作放在一个事务
   2. 分布式系统，利用TCC等分布式事务方案

3. 先操作缓存还是先操作数据库？

    * 先删除缓存，再操作数据库
    * 先操作数据库，再删除缓存

     应该具体操作缓存还是操作数据库，**我们应当是先操作数据库，再删除缓存**，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。

   ​	先操作数据库在删除缓存，理论上也会出现问题，线程1查询在缓存中没有的数据，就会查询数据库将数据库查到的age =20，写入缓存，但在这时还未写入缓存，线程2，操作数据库age=21，删除缓存。此时线程1继续写入缓存age=20，又会出现不一致现象。但是在实际中并不太可能发生，因为写入缓存的时间是极快的。





​	



